// Generated by CoffeeScript 1.3.3
(function() {
  var engine, fs, path, states, util, utils, view,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  view = require('./view').view;

  states = require('./consts').states;

  utils = require('./utils');

  fs = require('fs');

  path = require('path');

  util = require('util');

  engine = (function() {

    function engine(options) {
      this._fn_partial = __bind(this._fn_partial, this);

      this._fn_snippet = __bind(this._fn_snippet, this);

      this._inlineInclude = __bind(this._inlineInclude, this);

      this.run = __bind(this.run, this);
      options = options || {};
      this.verbose = options.verbose || false;
      this.prettyPrintErrors = options.prettyPrintErrors || false;
      this.viewCache = {};
    }

    engine.prototype._log = function(o) {
      var _ref;
      if (this.verbose) {
        if ((_ref = typeof o) === "string" || _ref === "number" || _ref === "boolean") {
          return console.log("toffee: " + o);
        } else {
          return console.log("toffee: " + (util.inspect(o)));
        }
      }
    };

    engine.prototype.run = function(filename, options, cb) {
      /*
          "options" contains the pub vars and may contain special items:
              layout:                  path to a template expecting a body var (express 2.x style, but for use with express 3.x)
              __toffee.dir:            path to look relative to
              __toffee.parent:         parent file
              __toffee.noInheritance:  if true, don't pass variables through unless explicitly passed
              __toffee.autoEscape:     if set as false, don't escape output of #{} vars by default
      */

      var err, res, _ref, _ref1, _ref2, _ref3;
      _ref = this.runSync(filename, options), err = _ref[0], res = _ref[1];
      if (err && this.prettyPrintErrors) {
        _ref1 = [null, err], err = _ref1[0], res = _ref1[1];
      }
      if ((!err) && (options != null ? options.layout : void 0)) {
        options.body = res;
        _ref2 = this.runSync(options.layout, options), err = _ref2[0], res = _ref2[1];
        if (err && this.prettyPrintErrors) {
          _ref3 = [null, err], err = _ref3[0], res = _ref3[1];
        }
      }
      return cb(err, res);
    };

    engine.prototype.runSync = function(filename, options) {
      /*
          "options" the same as run() above
      */

      var err, pwd, realpath, res, start_time, v, _ref, _ref1,
        _this = this;
      start_time = Date.now();
      options = options || {};
      options.__toffee = options.__toffee || {};
      options.__toffee.dir = options.__toffee.dir || process.cwd();
      filename = filename[0] !== "/" ? "" + options.__toffee.dir + "/" + filename : filename;
      realpath = path.normalize(filename);
      pwd = path.dirname(realpath);
      v = this.viewCache[realpath] || this._loadCacheAndMonitor(realpath, options);
      if (v) {
        options.__toffee.parent = realpath;
        options.partial = options.partial || function(fname, lvars) {
          return _this._fn_partial(fname, lvars, realpath, options);
        };
        options.snippet = options.snippet || function(fname, lvars) {
          return _this._fn_snippet(fname, lvars, realpath, options);
        };
        options.print = options.print || function(txt) {
          return _this._fn_print(txt, options);
        };
        if (!(options.console != null)) {
          options.console = {
            log: console.log
          };
        }
        _ref = v.run(options), err = _ref[0], res = _ref[1];
      } else {
        _ref1 = ["Couldn't load " + realpath, null], err = _ref1[0], res = _ref1[1];
      }
      this._log("" + realpath + " run in " + (Date.now() - start_time) + "ms");
      return [err, res];
    };

    engine.prototype._inlineInclude = function(filename, local_vars, parent_realpath, parent_options) {
      var err, k, options, res, v, _ref;
      options = local_vars || {};
      options.__toffee = options.__toffee || {};
      options.__toffee.dir = path.dirname(parent_realpath);
      options.__toffee.parent = parent_realpath;
      if (!options.__toffee.noInheritance) {
        for (k in parent_options) {
          v = parent_options[k];
          if (!((local_vars != null ? local_vars[k] : void 0) != null)) {
            if (!(k === "print" || k === "partial" || k === "snippet" || k === "layout" || k === "__toffee")) {
              options[k] = v;
            }
          }
        }
      }
      _ref = this.runSync(filename, options), err = _ref[0], res = _ref[1];
      return err || res;
    };

    engine.prototype._fn_snippet = function(fname, lvars, realpath, options) {
      lvars = lvars != null ? lvars : {};
      lvars.__toffee = lvars.__toffee || {};
      lvars.__toffee.noInheritance = true;
      return this._inlineInclude(fname, lvars, realpath, options);
    };

    engine.prototype._fn_partial = function(fname, lvars, realpath, options) {
      return this._inlineInclude(fname, lvars, realpath, options);
    };

    engine.prototype._fn_print = function(txt, options) {
      if (options.__toffee.state === states.COFFEE) {
        options.__toffee.out.push(txt);
        return '';
      } else {
        return txt;
      }
    };

    engine.prototype._loadCacheAndMonitor = function(filename, options) {
      var txt, v, view_options, _ref;
      try {
        txt = fs.readFileSync(filename, 'utf8');
      } catch (e) {
        txt = "Error: Could not read " + filename;
        if (((_ref = options.__toffee) != null ? _ref.parent : void 0) != null) {
          txt += " requested in " + options.__toffee.parent;
        }
      }
      view_options = {
        fileName: filename,
        verbose: this.verbose,
        prettyPrintErrors: this.prettyPrintErrors
      };
      v = new view(txt, view_options);
      this.viewCache[filename] = v;
      this._monitorForChanges(filename, options);
      return v;
    };

    engine.prototype._monitorForChanges = function(filename, options) {
      /*
          we must continuously unwatch/rewatch because some editors/systems invoke a "rename"
          event and we'll end up following the wrong, old 'file' as a new one
          is dropped in its place.
      */

      var fsw,
        _this = this;
      fsw = null;
      return fsw = fs.watch(filename, {
        persistent: true
      }, function(change) {
        fsw.close();
        _this._log("Got an fs.watch hit on " + filename);
        return fs.readFile(filename, 'utf8', function(err, txt) {
          var v, view_options, _ref;
          _this._monitorForChanges(filename, options);
          if (txt !== _this.viewCache[filename].txt) {
            if (err) {
              txt = "Error: Could not read " + filename + " after fs.watch() hit.";
              if (((_ref = options.__toffee) != null ? _ref.parent : void 0) != null) {
                txt += " requested in " + options.__toffee.parent;
              }
            }
            view_options = {
              fileName: filename,
              verbose: _this.verbose,
              prettyPrintErrors: _this.prettyPrintErrors,
              cb: function(v) {
                _this._log("" + filename + " updated and ready");
                return _this.viewCache[filename] = v;
              }
            };
            return v = new view(txt, view_options);
          }
        });
      });
    };

    return engine;

  })();

  exports.engine = engine;

}).call(this);
