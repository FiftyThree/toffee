// Generated by IcedCoffeeScript 1.3.1c
(function() {
  var TAB_SPACES, coffee, parser, view, vm;

  parser = require('./cojo_lang').parser;

  coffee = require('coffee-script');

  vm = require('vm');

  TAB_SPACES = 2;

  view = (function() {

    function view(txt) {
      this.codeObj = null;
      this.coffeeScript = null;
      this.javaScript = null;
      this.scriptObj = null;
      this.loadFromText(txt);
    }

    view.prototype.loadFromText = function(txt) {
      this.txt = txt;
      this.codeObj = parser.parse(txt);
      this._cleanTabs();
      console.log(" =====txt=======");
      console.log(this.txt);
      console.log(" =====code=======");
      console.log(JSON.stringify(this.codeObj));
      return console.log(" ============");
    };

    view.prototype._cleanTabs = function() {
      var chunk, i, tab, _i, _len, _ref, _results;
      tab = this._tabAsSpaces();
      _ref = this.codeObj;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        chunk = _ref[i];
        if (chunk[0] === 'COFFEE') {
          _results.push(chunk[1] = chunk[1].replace(/\t/g, tab));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    view.prototype.run = function(vars, options) {
      /*
          returns [err, str]
      */

      var err, fn, name, res, script, _ref;
      script = this._toScriptObj();
      vars.__cojo__ = {
        res: ""
      };
      err = null;
      if (options.prebuilt_functions != null) {
        _ref = options.prebuilt_functions;
        for (name in _ref) {
          fn = _ref[name];
          vars[name] = fn;
        }
      }
      try {
        script.runInNewContext(vars);
        res = vars.__cojo__.res;
        delete vars.__cojo__;
      } catch (e) {
        err = "Error: " + e.message;
        err += "\nStack: " + e.stack;
      }
      return [err, res];
    };

    view.prototype._toScriptObj = function() {
      var d, txt;
      if (!(this.scriptObj != null)) {
        txt = this._toJavascript();
        d = Date.now();
        this.scriptObj = vm.createScript(txt);
        console.log("Compiled to ScriptObj in " + (Date.now() - d) + "ms");
      }
      return this.scriptObj;
    };

    view.prototype._toJavascript = function() {
      var c, d;
      if (!(this.javaScript != null)) {
        c = this._toCoffee();
        d = Date.now();
        this.javaScript = coffee.compile(c, {
          bare: false
        });
        console.log("Compiled to JavaScript in " + (Date.now() - d) + "ms");
      }
      return this.javaScript;
    };

    view.prototype._toCoffee = function() {
      var d, res;
      if (!(this.coffeeScript != null)) {
        d = Date.now();
        res = this._coffeeHeaders();
        res += this._toCoffeeRecurse(this.codeObj, 0, 0);
        res += this._coffeeFooters();
        this.coffeeScript = res;
        console.log(res);
        console.log("Compiled to CoffeeScript in " + (Date.now() - d) + "ms");
      }
      return this.coffeeScript;
    };

    view.prototype._toCoffeeRecurse = function(obj, indent_level, indent_baseline) {
      var item, rel_baseline, res, zone_baseline, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      res = "";
      switch (obj[0]) {
        case "INDENTED_COJO_ZONE":
          indent_level += TAB_SPACES;
          _ref = obj[1];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            item = _ref[_i];
            res += this._toCoffeeRecurse(item, indent_level, indent_baseline);
          }
          break;
        case "COJO_ZONE":
          res += "\n" + (this._space(indent_level)) + "__cojo__.state = \"COJO\"";
          _ref1 = obj[1];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            item = _ref1[_j];
            res += this._toCoffeeRecurse(item, indent_level, indent_baseline);
          }
          break;
        case "COFFEE_ZONE":
          res += "\n" + (this._space(indent_level)) + "__cojo__.state = \"COFFEE\"";
          zone_baseline = this._getZoneBaseline(obj[1]);
          indent_baseline = zone_baseline;
          _ref2 = obj[1];
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            item = _ref2[_k];
            res += this._toCoffeeRecurse(item, indent_level, indent_baseline);
            if (item[0] === "COFFEE") {
              rel_baseline = this._getIndentationBaseline(item[1], zone_baseline);
              console.log("Rel = " + rel_baseline + " Baseline = " + zone_baseline);
              indent_level = rel_baseline;
            }
          }
          break;
        case "COJO":
          res += "\n" + (this._space(indent_level)) + "__cojo__.state = \"COJO\"";
          res += ("\n" + (this._space(indent_level)) + "__cojo__.res += ") + '"""' + obj[1] + '"""';
          res += "\n" + (this._space(indent_level)) + "__cojo__.state = \"COFFEE\"";
          break;
        case "COFFEE":
          console.log(obj);
          res += "" + (this._space(indent_level)) + "# DEBUG: indent_level=" + indent_level + " indent_baseline=" + indent_baseline;
          res += "\n" + (this._reindent(obj[1], indent_level, indent_baseline));
          break;
        default:
          throw "Bad parsing. " + obj + " not handled.";
          return "";
      }
      return res;
    };

    view.prototype._getZoneBaseline = function(obj_arr) {
      var ib, obj, _i, _len;
      for (_i = 0, _len = obj_arr.length; _i < _len; _i++) {
        obj = obj_arr[_i];
        if (obj[0] === "COFFEE") {
          ib = this._getIndentationBaseline(obj[1]);
          if (ib != null) return ib;
        }
      }
      return 0;
    };

    view.prototype._getIndentationBaseline = function(coffee) {
      var line, lines, _i, _len;
      lines = coffee.split("\n");
      if (lines.length === 0) return null;
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        if (!line.match(/^[\W]*$/)) return line.match(/[\W]*/)[0].length;
      }
      return null;
    };

    view.prototype._getIndentationDelta = function(coffee, baseline) {
      /*
          given an arbitrarily indented set of coffeescript, returns the delta
          between the first and last lines, in chars.
          Ignores leading/trailing whitespace lines
          If passed a baseline, uses that instead of own.
      */

      var lines, res, y, y_l;
      if (!(baseline != null)) baseline = this._getIndentationBaseline(coffee);
      if (!(baseline != null)) return 0;
      lines = coffee.split("\n");
      while (lines.length && lines[lines.length - 1].match(/^[\W]*$/)) {
        lines.pop();
      }
      if (lines.length < 1) return 0;
      y = lines[lines.length - 1];
      y_l = y.match(/[\W]*/)[0].length;
      res = y_l - baseline;
      return res;
    };

    view.prototype._reindent = function(coffee, indent_level, indent_baseline) {
      var indent, line, lines, res, rxx, strip;
      lines = coffee.split('\n');
      while (lines.length && lines[0].match(/^[\W]*$/)) {
        lines = lines.slice(1);
      }
      if (!lines.length) return '';
      rxx = /^[\W]*/;
      strip = indent_baseline;
      indent = this._space(indent_level);
      res = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          _results.push("" + indent + line.slice(strip));
        }
        return _results;
      })()).join("\n");
      return res;
    };

    view.prototype._space = function(indent) {
      var i;
      return ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= indent ? _i < indent : _i > indent; i = 0 <= indent ? ++_i : --_i) {
          _results.push(" ");
        }
        return _results;
      })()).join("");
    };

    view.prototype._tabAsSpaces = function() {
      var i;
      return ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= TAB_SPACES ? _i < TAB_SPACES : _i > TAB_SPACES; i = 0 <= TAB_SPACES ? ++_i : --_i) {
          _results.push(" ");
        }
        return _results;
      })()).join("");
    };

    view.prototype._coffeeHeaders = function() {
      var header;
      header = "";
      return header;
    };

    view.prototype._coffeeFooters = function() {
      var footer;
      footer = "";
      return footer;
    };

    return view;

  })();

  exports.view = view;

}).call(this);
