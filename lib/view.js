// Generated by CoffeeScript 1.3.3
(function() {
  var TAB_SPACES, coffee, parser, states, view, vm;

  parser = require('./toffee_lang').parser;

  try {
    coffee = require("iced-coffee-script");
  } catch (e) {
    coffee = require("coffee-script");
  }

  states = require('./consts').states;

  vm = require('vm');

  TAB_SPACES = 2;

  view = (function() {

    function view(txt, options) {
      options = options || {};
      this.fileName = (options.fileName || options.filename) || null;
      this.identifier = options.indentifier || "pub";
      this.codeObj = null;
      this.coffeeScript = null;
      this.javaScript = null;
      this.scriptObj = null;
      this.error = null;
      this.loadFromText(txt);
    }

    view.prototype.loadFromText = function(txt) {
      this.txt = txt;
      try {
        this.codeObj = parser.parse(txt);
        return this._cleanTabs();
      } catch (e) {
        return this._generateParseError(e, txt);
      }
    };

    view.prototype._cleanTabs = function() {
      var chunk, i, tab, _i, _len, _ref, _results;
      tab = this._tabAsSpaces();
      _ref = this.codeObj;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        chunk = _ref[i];
        if (chunk[0] === 'COFFEE') {
          _results.push(chunk[1] = chunk[1].replace(/\t/g, tab));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    view.prototype.run = function(options) {
      /*
          returns [err, str]
      */

      var err, res, sandbox, script;
      script = this._toScriptObj();
      err = null;
      if (this.error) {
        console.log(this.error.converted_msg);
        return [this._prettyPrintError(), ""];
      } else {
        try {
          sandbox = {
            __toffee_run_input: options
          };
          script.runInNewContext(sandbox);
          res = sandbox.__toffee_run_input.__toffee.res;
          delete sandbox.__toffee_run_input.__toffee;
        } catch (e) {
          this._generateRuntimeError(e);
          console.log(this.error.converted_msg);
          return [this._prettyPrintError(), this._prettyPrintError()];
        }
        return [err, res];
      }
    };

    view.prototype._ppEscape = function(txt) {
      var i, m;
      txt = txt.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      m = txt.match(/^[\t ]*/);
      return txt = txt.replace(m[0], ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = m[0].length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push("&nbsp;");
        }
        return _results;
      })()).join(""));
    };

    view.prototype._prettyPrintError = function() {
      var i, line, lineno, res, txt_lines, _i, _ref, _ref1;
      if (!this.error) {
        return "";
      } else {
        res = "<div style=\"border:1px solid #999;margin:10px;padding:10px;background-color:#fff;position:fixed;top:0;left:0;width:100%;z-index:9999;\">";
        res += "<b>" + (this._ppEscape(this.error.converted_msg)) + "</b>";
        res += "\n  <br />--------<br />";
        res += "\n<div style=\"font-family:courier new;font-size:10pt;color:#900;\">";
        txt_lines = this.txt.split('\n');
        for (i = _i = _ref = this.error.toffee_line_range[0] - 3, _ref1 = this.error.toffee_line_range[1] + 1; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
          if ((i < 0) || i > txt_lines.length - 1) {
            continue;
          }
          line = this._ppEscape(txt_lines[i]);
          lineno = i + 1;
          res += "\n" + lineno + ": " + line + " <br />";
        }
        res += "\n</div>";
        res += "\n</div>";
        return res;
      }
    };

    view.prototype._generateParseError = function(e) {
      /*
          e: the error caught when compiling
          so that we can handle outputting this error
          the same as compile errors, we'll produce a similar object
          to _generateCompileError
      */

      var msg, res, search;
      msg = e.message;
      res = {
        src_line: 0,
        toffee_line_range: [0, 1],
        original_msg: msg,
        converted_msg: msg
      };
      search = msg.match(/on line ([0-9]+)/);
      if (!((search != null ? search.length : void 0) >= 2)) {
        return res;
      }
      res.src_line = parseInt(search[1]);
      res.toffee_line_range = [res.src_line, res.src_line];
      if (this.fileName) {
        res.converted_msg = "" + this.fileName + ": " + res.converted_msg;
      }
      this.error = res;
      return res;
    };

    view.prototype._generateRuntimeError = function(e) {
      /*
          when everything compiled to JS fine, but we hit a runtime error.
          e: the error caught when compiling
          Creates an object like _generateCompileError
      */

      var after, after_matches, before, msg, new_msg, prev_matches, res, search, src, src_lines, stack, txt_lines;
      src = this.javaScript;
      msg = e.message;
      stack = e.stack;
      res = {
        src_line: 0,
        toffee_line_range: [0, 1],
        original_msg: msg,
        converted_msg: msg
      };
      search = stack.match(/([0-9]+):[0-9]+/);
      if (!((search != null ? search.length : void 0) >= 2)) {
        return res;
      }
      res.src_line = search[1];
      src_lines = src.split('\n');
      txt_lines = this.txt.split('\n');
      before = src_lines.slice(0, res.src_line).join("\n");
      after = src_lines.slice(res.src_line).join("\n");
      prev_matches = before.match(/__toffee.lineno[ ]*=[ ]*([0-9]+)/g);
      after_matches = after.match(/__toffee.lineno[ ]*=[ ]*([0-9]+)/g);
      if (prev_matches != null ? prev_matches.length : void 0) {
        res.toffee_line_range[0] = parseInt(prev_matches[prev_matches.length - 1].match(/[0-9]+/)[0]);
      } else {
        res.toffee_line_range[0] = 1;
      }
      if (after_matches != null ? after_matches.length : void 0) {
        res.toffee_line_range[1] = parseInt(after_matches[0].match(/[0-9]+/)[0]);
      } else {
        res.toffee_line_range[1] = txt_lines.length;
      }
      res.offensive_lines = txt_lines.slice(res.toffee_line_range[0] - 1, res.toffee_line_range[1] - 1);
      if (res.toffee_line_range[0] === res.toffee_line_range[1]) {
        new_msg = "on line " + res.toffee_line_range[0];
      } else {
        new_msg = "between lines " + res.toffee_line_range[0] + " and " + res.toffee_line_range[1];
      }
      res.converted_msg = res.original_msg + " " + new_msg;
      if (this.fileName) {
        res.converted_msg = "" + this.fileName + ": " + res.converted_msg;
      }
      this.error = res;
      return res;
    };

    view.prototype._generateCompileToJsError = function(e) {
      /*
      
          e: the error caught when compiling
      
          Creates an object like this and stores in @error
          {
            src_line:    14
            toffee_line_range: [6,8]
            original_msg:  'reserved word "var" on line 14'
            converted_msg: 'reserved word "var" between lines 6 and 8'
            offensive_lines: (array of lines)
          }
      */

      var after, after_matches, before, msg, new_msg, prev_matches, res, search, src, src_lines, txt_lines;
      src = this.coffeeScript;
      msg = e.message;
      res = {
        src_line: 0,
        toffee_line_range: [0, 1],
        original_msg: msg,
        converted_msg: msg
      };
      search = msg.match(/on line ([0-9]+)/);
      if (!((search != null ? search.length : void 0) >= 2)) {
        return res;
      }
      res.src_line = search[1];
      src_lines = src.split('\n');
      txt_lines = this.txt.split('\n');
      before = src_lines.slice(0, res.src_line).join("\n");
      after = src_lines.slice(res.src_line).join("\n");
      prev_matches = before.match(/__toffee.lineno[ ]*=[ ]*([0-9]+)/g);
      after_matches = after.match(/__toffee.lineno[ ]*=[ ]*([0-9]+)/g);
      if (prev_matches != null ? prev_matches.length : void 0) {
        res.toffee_line_range[0] = parseInt(prev_matches[prev_matches.length - 1].match(/[0-9]+/)[0]);
      } else {
        res.toffee_line_range[0] = 1;
      }
      if (after_matches != null ? after_matches.length : void 0) {
        res.toffee_line_range[1] = parseInt(after_matches[0].match(/[0-9]+/)[0]);
      } else {
        res.toffee_line_range[1] = txt_lines.length;
      }
      res.offensive_lines = txt_lines.slice(res.toffee_line_range[0] - 1, res.toffee_line_range[1] - 1);
      if (res.toffee_line_range[0] === res.toffee_line_range[1]) {
        new_msg = "on line " + res.toffee_line_range[0];
      } else {
        new_msg = "between lines " + res.toffee_line_range[0] + " and " + res.toffee_line_range[1];
      }
      res.converted_msg = res.original_msg.replace("on line " + res.src_line, new_msg);
      if (this.fileName) {
        res.converted_msg = "" + this.fileName + ": " + res.converted_msg;
      }
      this.error = res;
      return res;
    };

    view.prototype._toScriptObj = function() {
      var d, txt;
      if (!((this.scriptObj != null) || (this.error != null))) {
        txt = this._toJavaScript();
        d = Date.now();
        this.scriptObj = vm.createScript(txt);
      }
      return this.scriptObj;
    };

    view.prototype._toJavaScript = function() {
      var c, d;
      if (!(this.javaScript != null)) {
        c = this._toCoffee();
        d = Date.now();
        try {
          this.javaScript = coffee.compile(c, {
            bare: false
          });
        } catch (e) {
          this._generateCompileToJsError(e);
        }
      }
      return this.javaScript;
    };

    view.prototype._toCoffee = function() {
      var d, res;
      if (!(this.coffeeScript != null)) {
        d = Date.now();
        res = this._coffeeHeaders();
        res += this._toCoffeeRecurse(this.codeObj, TAB_SPACES, 0)[0];
        res += this._coffeeFooters();
        this.coffeeScript = res;
      }
      return this.coffeeScript;
    };

    view.prototype._toCoffeeRecurse = function(obj, indent_level, indent_baseline) {
      var c, delta, i, i_delta, item, lbreak, line, lines, res, s, temp_indent_level, zone_baseline, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      res = "";
      i_delta = 0;
      switch (obj[0]) {
        case "INDENTED_TOFFEE_ZONE":
          indent_level += TAB_SPACES;
          _ref = obj[1];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            item = _ref[_i];
            _ref1 = this._toCoffeeRecurse(item, indent_level, indent_baseline), s = _ref1[0], delta = _ref1[1];
            res += s;
          }
          break;
        case "TOFFEE_ZONE":
          res += "\n" + (this._space(indent_level)) + "__toffee.state  = states.TOFFEE";
          _ref2 = obj[1];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            item = _ref2[_j];
            _ref3 = this._toCoffeeRecurse(item, indent_level, indent_baseline), s = _ref3[0], delta = _ref3[1];
            res += s;
          }
          break;
        case "COFFEE_ZONE":
          res += "\n" + (this._space(indent_level)) + "__toffee.state = states.COFFEE";
          zone_baseline = this._getZoneBaseline(obj[1]);
          temp_indent_level = indent_level;
          _ref4 = obj[1];
          for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
            item = _ref4[_k];
            _ref5 = this._toCoffeeRecurse(item, temp_indent_level, zone_baseline), s = _ref5[0], delta = _ref5[1];
            res += s;
            temp_indent_level = indent_level + delta;
          }
          break;
        case "TOFFEE":
          res += "\n" + (this._space(indent_level)) + "__toffee.lineno = " + obj[2];
          res += "\n" + (this._space(indent_level)) + "__toffee.state = states.TOFFEE";
          lines = obj[1].split("\n");
          for (i = _l = 0, _len3 = lines.length; _l < _len3; i = ++_l) {
            line = lines[i];
            if (!line.match(/#/)) {
              if (i) {
                res += "\n" + (this._space(indent_level)) + "__toffee.lineno = " + (obj[2] + i);
              }
              lbreak = i !== lines.length - 1 ? "\n" : "";
              res += ("\n" + (this._space(indent_level)) + "__toffee.out.push ") + '"""' + this._escapeForStr(line + lbreak) + '"""';
            } else {
              res += ("\n" + (this._space(indent_level)) + "__toffee.out.push ") + '"""' + this._escapeForStr(lines.slice(i).join("\n")) + '"""';
              break;
            }
          }
          res += "\n" + (this._space(indent_level)) + "__toffee.lineno = " + (obj[2] + (obj[1].split('\n').length - 1));
          res += "\n" + (this._space(indent_level)) + "__toffee.state = states.COFFEE";
          break;
        case "COFFEE":
          c = "" + obj[1];
          res += "\n" + (this._reindent(c, indent_level, indent_baseline));
          i_delta = this._getIndentationDelta(obj[1], indent_baseline);
          break;
        default:
          throw "Bad parsing. " + obj + " not handled.";
          return ["", 0];
      }
      return [res, i_delta];
    };

    view.prototype._escapeForStr = function(s) {
      /*
          escapes a string so it can make it into coffeescript
          triple quotes without losing whitespace, etc.
      */
      s = s.replace(/\n/g, '\\n');
      s = s.replace(/\t/g, '\\t');
      return s;
    };

    view.prototype._getZoneBaseline = function(obj_arr) {
      var ib, obj, _i, _len;
      for (_i = 0, _len = obj_arr.length; _i < _len; _i++) {
        obj = obj_arr[_i];
        if (obj[0] === "COFFEE") {
          ib = this._getIndentationBaseline(obj[1]);
          if (ib != null) {
            return ib;
          }
        }
      }
      return 0;
    };

    view.prototype._getIndentationBaseline = function(coffee) {
      var line, lines, res, _i, _len;
      res = null;
      lines = coffee.split("\n");
      if (lines.length !== 0) {
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          if (!line.match(/^[ ]*$/)) {
            res = line.match(/[ ]*/)[0].length;
            break;
          }
        }
      }
      return res;
    };

    view.prototype._getIndentationDelta = function(coffee, baseline) {
      /*
          given an arbitrarily indented set of coffeescript, returns the delta
          between the first and last lines, in chars.
          Ignores leading/trailing whitespace lines
          If passed a baseline, uses that instead of own.
      */

      var lines, res, y, y_l;
      if (!(baseline != null)) {
        baseline = this._getIndentationBaseline(coffee);
      }
      if (!(baseline != null)) {
        res = 0;
      } else {
        lines = coffee.split("\n");
        while (lines.length && lines[lines.length - 1].match(/^[ ]*$/)) {
          lines.pop();
        }
        if (lines.length < 1) {
          res = 0;
        } else {
          y = lines[lines.length - 1];
          y_l = y.match(/[ ]*/)[0].length;
          res = y_l - baseline;
        }
      }
      return res;
    };

    view.prototype._reindent = function(coffee, indent_level, indent_baseline) {
      var indent, line, lines, res, rxx, strip;
      lines = coffee.split('\n');
      while (lines.length && lines[0].match(/^[ ]*$/)) {
        lines = lines.slice(1);
      }
      if (!lines.length) {
        return '';
      }
      rxx = /^[ ]*/;
      strip = indent_baseline;
      indent = this._space(indent_level);
      res = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          _results.push("" + indent + line.slice(strip));
        }
        return _results;
      })()).join("\n");
      return res;
    };

    view.prototype._space = function(indent) {
      var i;
      return ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= indent ? _i < indent : _i > indent; i = 0 <= indent ? ++_i : --_i) {
          _results.push(" ");
        }
        return _results;
      })()).join("");
    };

    view.prototype._tabAsSpaces = function() {
      var i;
      return ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= TAB_SPACES ? _i < TAB_SPACES : _i > TAB_SPACES; i = 0 <= TAB_SPACES ? ++_i : --_i) {
          _results.push(" ");
        }
        return _results;
      })()).join("");
    };

    view.prototype._coffeeHeaders = function() {
      var header, tab;
      tab = this._tabAsSpaces();
      header = "domain                  = this\ndomain.toffeeTemplates  = domain.toffeeTemplates or {}\ndomain.toffeeTemplates[\"" + this.identifier + "\"] = (locals) ->\n" + tab + "domain                = this\n" + tab + "locals.__toffee       = {}\n" + tab + "`with (locals) {`\n" + tab + "__toffee.out = []\n" + tab + "states = " + (JSON.stringify(states));
      return header;
    };

    view.prototype._coffeeFooters = function() {
      var footer, tab;
      tab = this._tabAsSpaces();
      footer = "\n\n" + tab + "__toffee.res = __toffee.out.join \"\"\n" + tab + "return __toffee.res\n" + tab + "`} /* closing JS 'with' */ `\n# sometimes we want to execute the whole thing in a sandbox\n# and just output results\nif __toffee_run_input?\n" + tab + "return domain.toffeeTemplates[\"" + this.identifier + "\"] __toffee_run_input\nif not print? then print = (txt) -> __toffee.out.push txt";
      return footer;
    };

    return view;

  })();

  exports.view = view;

  exports.expressCompile = function(txt, options) {
    var v;
    v = new view(txt, options);
    return function(vars) {
      var res;
      res = v.run(vars);
      if (res[0]) {
        return res[0];
      } else {
        return res[1];
      }
    };
  };

}).call(this);
