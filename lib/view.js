// Generated by CoffeeScript 1.3.3
(function() {
  var TAB_SPACES, coffee, errorHandler, parser, states, utils, view, vm, _ref;

  parser = require('./toffee_lang').parser;

  errorHandler = require('./errorHandler').errorHandler;

  _ref = require('./consts'), states = _ref.states, TAB_SPACES = _ref.TAB_SPACES;

  utils = require('./utils');

  vm = require('vm');

  try {
    coffee = require("iced-coffee-script");
  } catch (e) {
    coffee = require("coffee-script");
  }

  view = (function() {

    function view(txt, options) {
      /*
          important options:
            cb: if this is set, compilation will happen async and cb will be executed when it's ready
      */

      var _this = this;
      options = options || {};
      this.fileName = (options.fileName || options.filename) || null;
      this.identifier = options.indentifier || "pub";
      this.verbose = options.verbose || false;
      this.txt = txt;
      this.tokenObj = null;
      this.coffeeScript = null;
      this.javaScript = null;
      this.scriptObj = null;
      this.error = null;
      if (options.cb) {
        this._prepAsync(txt, function() {
          return options.cb(_this);
        });
      }
    }

    view.prototype._prepAsync = function(txt, cb) {
      /*
          Only once it's fully compiled does it callback.
          Defers via setTimeouts in each stage in the compile process
          for CPU friendliness. This is a lot prettier with iced-coffee-script.
      */

      var v;
      this._log("Prepping " + (this.fileName != null ? this.fileName : 'unknown') + " async.");
      this._toTokenObj();
      v = this;
      return setTimeout(function() {
        v._toCoffee();
        return setTimeout(function() {
          v._toJavaScript();
          return setTimeout(function() {
            v._toScriptObj();
            v._log("Done async prep of " + (v.fileName != null ? v.fileName : 'unknown') + ". Calling back.");
            return cb();
          }, 0);
        }, 0);
      }, 0);
    };

    view.prototype._log = function(o) {
      var _ref1;
      if (this.verbose) {
        if ((_ref1 = typeof o) === "string" || _ref1 === "number" || _ref1 === "boolean") {
          return console.log("toffee: " + o);
        } else {
          return console.log("toffee: " + (util.inspect(o)));
        }
      }
    };

    view.prototype._cleanTabs = function(obj) {
      /*
          replaces tabs with spaces in their coffee regions
      */

      var item, _i, _len, _ref1, _ref2, _results;
      if ((_ref1 = obj[0]) === "INDENTED_TOFFEE_ZONE" || _ref1 === "TOFFEE_ZONE" || _ref1 === "COFFEE_ZONE") {
        _ref2 = obj[1];
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          item = _ref2[_i];
          _results.push(this._cleanTabs(item));
        }
        return _results;
      } else if (obj[0] === "COFFEE") {
        return obj[1] = obj[1].replace(/\t/g, this._tabAsSpaces());
      }
    };

    view.prototype.run = function(options) {
      /*
          returns [err, str]
      */

      var err, pp, res, sandbox, script;
      script = this._toScriptObj();
      err = null;
      if (this.error) {
        console.log(this.error.converted_msg);
        return [errorHandler.prettyPrintError(this, null)];
      } else {
        try {
          sandbox = {
            __toffee_run_input: options
          };
          script.runInNewContext(sandbox);
          res = sandbox.__toffee_run_input.__toffee.res;
          delete sandbox.__toffee_run_input.__toffee;
        } catch (e) {
          this.error = errorHandler.generateRuntimeError(this, e);
          console.log(this.error.converted_msg);
          pp = errorHandler.prettyPrintError(this);
          return [pp, null];
        }
        return [err, res];
      }
    };

    view.prototype._toTokenObj = function() {
      /*
          compiles Toffee to token array
      */
      if (!(this.tokenObj != null)) {
        try {
          this.tokenObj = parser.parse(this.txt);
          this._cleanTabs(this.tokenObj);
        } catch (e) {
          this.error = errorHandler.generateParseError(this, e);
        }
      }
      return this.tokenObj;
    };

    view.prototype._toScriptObj = function() {
      var d, txt;
      if (!((this.scriptObj != null) || (this.error != null))) {
        txt = this._toJavaScript();
        d = Date.now();
        this.scriptObj = vm.createScript(txt);
        this._log("" + this.fileName + " compiled to scriptObj in " + (Date.now() - d) + "ms");
      }
      return this.scriptObj;
    };

    view.prototype._toJavaScript = function() {
      var c, d;
      if (!(this.javaScript != null)) {
        c = this._toCoffee();
        d = Date.now();
        try {
          this.javaScript = coffee.compile(c, {
            bare: false
          });
        } catch (e) {
          this.error = errorHandler.generateCompileToJsError(this, e);
        }
        this._log("" + this.fileName + " compiled to JavaScript in " + (Date.now() - d) + "ms");
      }
      return this.javaScript;
    };

    view.prototype._toCoffee = function() {
      var d, res, tobj;
      if (!(this.coffeeScript != null)) {
        tobj = this._toTokenObj();
        d = Date.now();
        res = this._coffeeHeaders();
        res += this._toCoffeeRecurse(tobj, TAB_SPACES, 0)[0];
        res += this._coffeeFooters();
        this.coffeeScript = res;
        this._log("" + this.fileName + " compiled to CoffeeScript in " + (Date.now() - d) + "ms");
      }
      return this.coffeeScript;
    };

    view.prototype._printLineNo = function(n, ind) {
      if ((this.lastLineNo != null) && (n === this.lastLineNo)) {
        return "";
      } else {
        this.lastLineNo = n;
        return "\n" + (this._space(ind)) + "__toffee.lineno = " + n;
      }
    };

    view.prototype._snippetHasEscapeOverride = function(str) {
      var token, _i, _len, _ref1;
      _ref1 = ['snippet', 'partial', 'raw', 'html', 'json', '__toffee.raw', '__toffee.html', '__toffee.json', 'JSON.stringify'];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        token = _ref1[_i];
        if (str.slice(0, token.length) === token) {
          return true;
        }
      }
      return false;
    };

    view.prototype._toCoffeeRecurse = function(obj, indent_level, indent_baseline) {
      var c, chunk, delta, i, i_delta, ind, interp, item, lbreak, line, lineno, lines, part, res, s, t_int, temp_indent_level, zone_baseline, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      res = "";
      i_delta = 0;
      switch (obj[0]) {
        case "INDENTED_TOFFEE_ZONE":
          indent_level += TAB_SPACES;
          _ref1 = obj[1];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            item = _ref1[_i];
            _ref2 = this._toCoffeeRecurse(item, indent_level, indent_baseline), s = _ref2[0], delta = _ref2[1];
            res += s;
          }
          break;
        case "TOFFEE_ZONE":
          res += "\n" + (this._space(indent_level)) + "__toffee.state  = states.TOFFEE";
          _ref3 = obj[1];
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            item = _ref3[_j];
            _ref4 = this._toCoffeeRecurse(item, indent_level, indent_baseline), s = _ref4[0], delta = _ref4[1];
            res += s;
          }
          break;
        case "COFFEE_ZONE":
          res += "\n" + (this._space(indent_level)) + "__toffee.state = states.COFFEE";
          zone_baseline = this._getZoneBaseline(obj[1]);
          temp_indent_level = indent_level;
          _ref5 = obj[1];
          for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
            item = _ref5[_k];
            _ref6 = this._toCoffeeRecurse(item, temp_indent_level, zone_baseline), s = _ref6[0], delta = _ref6[1];
            res += s;
            temp_indent_level = indent_level + delta;
          }
          break;
        case "TOFFEE":
          ind = indent_level;
          res += "\n" + (this._space(ind)) + "__toffee.state = states.TOFFEE";
          t_int = utils.interpolateString(obj[1]);
          lineno = obj[2];
          for (_l = 0, _len3 = t_int.length; _l < _len3; _l++) {
            part = t_int[_l];
            if (part[0] === "TOKENS") {
              res += this._printLineNo(lineno, ind);
              interp = part[1].replace(/^[\n \t]+/, '');
              if (this._snippetHasEscapeOverride(interp)) {
                chunk = "\#{" + interp + "}";
              } else {
                chunk = "\#{escape(" + interp + ")}";
              }
              res += "\n" + (this._space(ind)) + "__toffee.out.push " + (this._quoteStr(chunk));
              lineno += part[1].split("\n").length - 1;
            } else {
              lines = part[1].split("\n");
              for (i = _m = 0, _len4 = lines.length; _m < _len4; i = ++_m) {
                line = lines[i];
                res += this._printLineNo(lineno, ind);
                lbreak = i !== lines.length - 1 ? "\n" : "";
                chunk = this._escapeForStr("" + line + lbreak);
                if (chunk.length) {
                  res += "\n" + (this._space(ind)) + "__toffee.out.push " + (this._quoteStr(chunk + lbreak));
                }
                if (i < lines.length - 1) {
                  lineno++;
                }
              }
            }
          }
          res += this._printLineNo(obj[2] + (obj[1].split('\n').length - 1), ind);
          res += "\n" + (this._space(ind)) + "__toffee.state = states.COFFEE";
          break;
        case "COFFEE":
          c = obj[1];
          res += "\n" + (this._reindent(c, indent_level, indent_baseline));
          i_delta = this._getIndentationDelta(c, indent_baseline);
          break;
        default:
          throw "Bad parsing. " + obj + " not handled.";
          return ["", 0];
      }
      return [res, i_delta];
    };

    view.prototype._quoteStr = function(s) {
      /*
          returns a triple-quoted string, dividing into single quoted
          start and stops, if the string begins with double quotes, since
          coffee doesn't want to let us escape those.
      */

      var follow, lead, res;
      lead = "";
      follow = "";
      while (s.length && (s[0] === '"')) {
        s = s.slice(1);
        lead += '"';
      }
      while (s.length && (s.slice(-1) === '"')) {
        s = s.slice(0, -1);
        follow += '"';
      }
      res = '';
      if (lead.length) {
        res += "\'" + lead + "\' + ";
      }
      res += '"""' + s + '"""';
      if (follow.length) {
        res += "+ \'" + follow + "\'";
      }
      return res;
    };

    view.prototype._escapeForStr = function(s) {
      /*
          escapes a string so it can make it into coffeescript
          triple quotes without losing whitespace, etc.
      */
      s = s.replace(/\n/g, '\\n');
      s = s.replace(/\t/g, '\\t');
      return s;
    };

    view.prototype._getZoneBaseline = function(obj_arr) {
      var ib, obj, _i, _len;
      for (_i = 0, _len = obj_arr.length; _i < _len; _i++) {
        obj = obj_arr[_i];
        if (obj[0] === "COFFEE") {
          ib = this._getIndentationBaseline(obj[1]);
          if (ib != null) {
            return ib;
          }
        }
      }
      return 0;
    };

    view.prototype._getIndentationBaseline = function(coffee) {
      var i, line, lines, res, _i, _len;
      res = null;
      lines = coffee.split("\n");
      if (lines.length) {
        for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
          line = lines[i];
          if ((!line.match(/^[ ]*$/)) || i === (lines.length - 1)) {
            res = line.match(/[ ]*/)[0].length;
            break;
          }
        }
      }
      if (!(res != null)) {
        res = coffee.length;
      }
      return res;
    };

    view.prototype._getIndentationDelta = function(coffee, baseline) {
      /*
          given an arbitrarily indented set of coffeescript, returns the delta
          between the first and last lines, in chars.
          Ignores leading/trailing whitespace lines
          If passed a baseline, uses that instead of own.
      */

      var lines, res, y, y_l;
      if (!(baseline != null)) {
        baseline = this._getIndentationBaseline(coffee);
      }
      if (!(baseline != null)) {
        res = 0;
      } else {
        lines = coffee.split("\n");
        if (lines.length < 1) {
          res = 0;
        } else {
          y = lines[lines.length - 1];
          y_l = y.match(/[ ]*/)[0].length;
          res = y_l - baseline;
        }
      }
      return res;
    };

    view.prototype._reindent = function(coffee, indent_level, indent_baseline) {
      var indent, line, lines, res, rxx, strip;
      lines = coffee.split('\n');
      while (lines.length && lines[0].match(/^[ ]*$/)) {
        lines = lines.slice(1);
      }
      if (!lines.length) {
        return '';
      }
      rxx = /^[ ]*/;
      strip = indent_baseline;
      indent = this._space(indent_level);
      res = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          _results.push("" + indent + line.slice(strip));
        }
        return _results;
      })()).join("\n");
      return res;
    };

    view.prototype._space = function(indent) {
      var i;
      return ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= indent ? _i < indent : _i > indent; i = 0 <= indent ? ++_i : --_i) {
          _results.push(" ");
        }
        return _results;
      })()).join("");
    };

    view.prototype._tabAsSpaces = function() {
      var i;
      return ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= TAB_SPACES ? _i < TAB_SPACES : _i > TAB_SPACES; i = 0 <= TAB_SPACES ? ++_i : --_i) {
          _results.push(" ");
        }
        return _results;
      })()).join("");
    };

    view.prototype._coffeeHeaders = function() {
      var ___;
      ___ = this._tabAsSpaces();
      return "domain                  = this\ndomain.toffeeTemplates  = domain.toffeeTemplates or {}\ndomain.toffeeTemplates[\"" + this.identifier + "\"] = (locals) ->\n" + ___ + "domain                = this\n" + ___ + "locals.__toffee       = {}\n" + ___ + "`with (locals) {`\n" + ___ + "__toffee.out = []\n\n" + ___ + "if not print?\n" + ___ + ___ + "print = (txt) -> \n" + ___ + ___ + ___ + "__toffee.out.push txt\n" + ___ + ___ + ___ + "''\n\n" + ___ + "__toffee.json = (o) ->\n" + ___ + ___ + "res = (\"\"+JSON.stringify o)\n\n" + ___ + "__toffee.html = (o) ->\n" + ___ + ___ + "res = (\"\"+o).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;')\n\n" + ___ + "__toffee.raw = (o) -> o\n\n" + ___ + "if not raw? then raw   = __toffee.raw\n" + ___ + "if not html? then html = __toffee.html\n" + ___ + "if not json? then json = __toffee.json\n\n" + ___ + "if not escape?\n" + ___ + ___ + "escape = (o) ->\n" + ___ + ___ + ___ + "if (not __toffee.autoEscape?) or __toffee.autoEscape\n" + ___ + ___ + ___ + ___ + "return __toffee.html o\n\n" + ___ + "states = " + (JSON.stringify(states));
    };

    view.prototype._coffeeFooters = function() {
      var ___;
      ___ = this._tabAsSpaces();
      return "\n\n" + ___ + "__toffee.res = __toffee.out.join \"\"\n" + ___ + "return __toffee.res\n" + ___ + "`} /* closing JS 'with' */ `\n# sometimes we want to execute the whole thing in a sandbox\n# and just output results\nif __toffee_run_input?\n" + ___ + "return domain.toffeeTemplates[\"" + this.identifier + "\"] __toffee_run_input";
    };

    return view;

  })();

  exports.view = view;

  exports.expressCompile = function(txt, options) {
    var v;
    v = new view(txt, options);
    return function(vars) {
      var res;
      res = v.run(vars);
      if (res[0]) {
        return res[0];
      } else {
        return res[1];
      }
    };
  };

}).call(this);
