// Generated by CoffeeScript 1.3.3
(function() {
  var eh, errorTypes, path, toffeeError, util, _ppEscape;

  path = require("path");

  util = require("util");

  errorTypes = exports.errorTypes = {
    PARSER: 0,
    STR_INTERPOLATE: 1,
    COFFEE_COMPILE: 2,
    RUNTIME: 3
  };

  toffeeError = (function() {

    function toffeeError(view, err_type, e) {
      this.errType = err_type;
      this.view = view;
      this.e = e;
      this.toffeeSrc = view.txt;
      console.log("Constructing " + err_type);
      switch (this.errType) {
        case errorTypes.PARSER:
          this.offensiveSrc = this.toffeeSrc;
          break;
        case errorTypes.STR_INTERPOLATE:
          this.offensiveSrc = this.toffeeSrc;
          break;
        case errorTypes.COFFEE_COMPILE:
          this.offensiveSrc = this.view.coffeeScript;
          break;
        case errorTypes.JS_RUNTIME:
          this.offensiveSrc = this.view.javaScript;
      }
      this.toffeeSrcLines = this.toffeeSrc.split("\n");
      this.offensiveSrcLines = this.offensiveSrc.split("\n");
    }

    toffeeError.prototype.getConvertedError = function() {
      /* --------------------------------------
      returns a JS style error, but with some extras
      {
        stack:      with converted line numbers
        message:    error message
        line_range: line range in the toffee file
        filename:   filename, if available; or null
        ...etc...
      }
      ------------------------------------------
      */

      var line, lr, res, todo, _ref, _ref1;
      res = {
        stack: [],
        message: "",
        type: this.errType,
        full_path: this.view.fileName,
        dir_name: path.dirname(this.view.fileName),
        file: path.basename(this.view.fileName),
        line_range: [0, 0]
      };
      if (((_ref = this.e) != null ? _ref.message : void 0) != null) {
        res.message = this.e.message;
      }
      if (((_ref1 = this.e) != null ? _ref1.stack : void 0) != null) {
        res.stack = this.e.stack;
      }
      switch (this.errType) {
        case errorTypes.PARSER:
          line = this._extractOffensiveLineNo(this.e.message, /on line ([0-9]+)/);
          res.line_range = [line, line + 1];
          res.stack = [];
          break;
        case errorTypes.STR_INTERPOLATE:
          console.log("DEALING WITH STR_INT");
          console.log(util.inspect(this.e));
          lr = this.e.relayed_line_range;
          res.line_range = [lr[0], lr[1]];
          res.message = res.message.replace('starting on line NaN', this._lineRangeToPhrase(res.line_range));
          res.stack = [];
          break;
        case errorTypes.COFFEE_COMPILE:
          todo = "TODO: THIS";
          break;
        case errorTypes.JS_RUNTIME:
          todo = "TODO: THIS";
      }
      return res;
    };

    toffeeError.prototype.getPrettyPrintText = function() {
      /*
          returns a TEXT only blob explaining the error
      */

      var cerr, header, res, _ref;
      cerr = this.getConvertedError();
      if (cerr.type === errorTypes.PARSER) {
        header = "" + cerr.dir_name + "/" + cerr.file + ": " + cerr.message;
      } else {
        header = cerr.message;
      }
      res = "---------------------\nERROR\n=====\n" + header;
      if ((_ref = cerr.stack) != null ? _ref.length : void 0) {
        res += "STACK\n=====\n" + cerr.stack + " ";
      }
      res += "---------------------";
      return res;
    };

    toffeeError.prototype.getPrettyPrint = function() {
      /*
          returns an HTML blob explaining the error 
          with lines highlighted
      */

      var cerr, extra, header, i, j, line, padding, padding_len, res, _i, _ref, _ref1, _ref2;
      cerr = this.getConvertedError();
      res = "";
      if (cerr.type === errorTypes.PARSER) {
        header = "" + cerr.dir_name + "/<b>" + cerr.file + "</b>: " + cerr.message;
      } else {
        header = cerr.message;
      }
      res += "<div style=\"border:1px solid #999;margin:10px;padding:10px;background-color:#fff;position:fixed;top:0;left:0;width:960px;z-index:9999;\">\n  \n<pre>" + header + "</pre>\n  \n<hr />\n  \n<div style=\"font-family:courier new;font-size:10pt;color:#900;\">        ";
      for (i = _i = _ref = cerr.line_range[0] - 3, _ref1 = cerr.line_range[1] + 1; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
        if ((i < 0) || i > this.toffeeSrcLines.length - 1) {
          continue;
        }
        line = _ppEscape(this.toffeeSrcLines[i]);
        padding_len = 5 - ("" + (i + 1)).length;
        padding = ((function() {
          var _j, _results;
          _results = [];
          for (j = _j = 0; 0 <= padding_len ? _j < padding_len : _j > padding_len; j = 0 <= padding_len ? ++_j : --_j) {
            _results.push("&nbsp;");
          }
          return _results;
        })()).join("");
        if ((cerr.line_range[0] <= (_ref2 = i + 1) && _ref2 < cerr.line_range[1])) {
          extra = "<span style=\"background-color:#fee\">";
        } else {
          extra = "<span>";
        }
        res += "" + extra + "\n" + (i + 1) + ": " + padding + " " + line + "</span><br />";
      }
      res += "  \n</div>\n\n</div>";
      return res;
    };

    toffeeError.prototype._lineRangeToPhrase = function(lrange) {
      if (lrange[0] === lrange[1] - 1) {
        return "on line " + lrange[0];
      } else {
        return "between lines " + lrange[0] + " and " + (lrange[1] - 1);
      }
    };

    toffeeError.prototype._extractOffensiveLineNo = function(msg, rxx) {
      var m;
      m = msg.match(rxx);
      if (!((m != null ? m.length : void 0) >= 2)) {
        return null;
      }
      return parseInt(m[1]);
    };

    toffeeError.prototype._convertOffensiveLineToToffeeRange = function(lineno) {
      /*
            Given the error line in a converted file, hunts for surrounding
            __toffee.lineno calls and returns a pair array with the error position
            range in the original toffee file.
      */

      var next, next_matches, ol, prev, prev_matches, res, tl;
      ol = this.offensiveSrcLines;
      tl = this.toffeeSrcLines;
      if ((!(lineno != null)) || isNaN(lineno)) {
        return [1, t1.length];
      }
      prev = ol.slice(0, lineno).join("\n");
      next = ol.slice(lineno).join("\n");
      prev_matches = prev.match(/__toffee.lineno[ ]*=[ ]*([0-9]+)/g);
      next_matches = next.match(/__toffee.lineno[ ]*=[ ]*([0-9]+)/g);
      res = [1, tl.length];
      if (prev_matches != null ? prev_matches.length : void 0) {
        res[0] = parseInt(prev_matches[prev_matches.length - 1].match(/[0-9]+/)[0]);
      }
      if (typeof after_matches !== "undefined" && after_matches !== null ? after_matches.length : void 0) {
        res[1] = parseInt(next_matches[0].match(/[0-9]+/)[0]);
      }
      return res;
    };

    return toffeeError;

  })();

  exports.toffeeError = toffeeError;

  eh = exports.errorHandler = {
    generateParseError: function(view, e) {
      /*
          e: the error caught when compiling
      */

      var msg, res, search;
      msg = e.message;
      res = {
        src_line: 0,
        toffee_line_range: [0, 1],
        original_msg: msg,
        converted_msg: msg
      };
      search = msg.match(/on line ([0-9]+)/);
      if (!((search != null ? search.length : void 0) >= 2)) {
        return res;
      }
      res.src_line = parseInt(search[1]);
      res.toffee_line_range = [res.src_line, res.src_line];
      if (view.fileName) {
        res.converted_msg = "" + view.fileName + ": " + res.converted_msg;
      }
      return res;
    },
    generateRuntimeError: function(view, e) {
      /*
          e: the error caught when running
      */

      var after, after_matches, before, msg, new_msg, prev_matches, res, search, src, src_lines, stack, txt_lines;
      console.log(e);
      src = view.javaScript;
      msg = e.message;
      stack = e.stack;
      res = {
        src_line: 0,
        toffee_line_range: [0, 1],
        original_msg: msg,
        converted_msg: msg
      };
      search = stack.match(/pub\ \(undefined\:([0-9]+):[0-9]+/);
      if (!((search != null ? search.length : void 0) >= 2)) {
        return res;
      }
      res.src_line = search[1];
      src_lines = src.split('\n');
      txt_lines = view.txt.split('\n');
      before = src_lines.slice(0, res.src_line).join("\n");
      after = src_lines.slice(res.src_line).join("\n");
      prev_matches = before.match(/__toffee.lineno[ ]*=[ ]*([0-9]+)/g);
      after_matches = after.match(/__toffee.lineno[ ]*=[ ]*([0-9]+)/g);
      if (prev_matches != null ? prev_matches.length : void 0) {
        res.toffee_line_range[0] = parseInt(prev_matches[prev_matches.length - 1].match(/[0-9]+/)[0]);
      } else {
        res.toffee_line_range[0] = 1;
      }
      if (after_matches != null ? after_matches.length : void 0) {
        res.toffee_line_range[1] = parseInt(after_matches[0].match(/[0-9]+/)[0]);
      } else {
        res.toffee_line_range[1] = txt_lines.length;
      }
      res.offensive_lines = txt_lines.slice(res.toffee_line_range[0] - 1, res.toffee_line_range[1] - 1);
      if (res.toffee_line_range[0] === res.toffee_line_range[1] - 1) {
        new_msg = "on line " + res.toffee_line_range[0];
      } else {
        new_msg = "between lines " + res.toffee_line_range[0] + " and " + res.toffee_line_range[1];
      }
      res.converted_msg = res.original_msg + " " + new_msg;
      if (view.fileName) {
        res.converted_msg = "" + view.fileName + ": " + res.converted_msg;
      }
      return res;
    },
    generateCompileToJsError: function(view, e) {
      /*
          e: the error caught when compiling
      */

      var msg, new_msg, res, search, src;
      src = view.coffeeScript;
      msg = e.message;
      res = {
        src_line: 0,
        toffee_line_range: [0, 1],
        original_msg: msg,
        converted_msg: msg
      };
      search = msg.match(/on line ([0-9]+)/);
      if ((search != null ? search.length : void 0) >= 2) {
        res.src_line = search[1];
        res.toffee_line_range = this._convertSrcLineToToffeeRange(view.coffeeScript, res.src_line);
        res.offensive_lines = txt_lines.slice(res.toffee_line_range[0] - 1, res.toffee_line_range[1] - 1);
        if (res.toffee_line_range[0] === res.toffee_line_range[1] - 1) {
          new_msg = "on line " + res.toffee_line_range[0];
        } else {
          new_msg = "between lines " + res.toffee_line_range[0] + " and " + res.toffee_line_range[1];
        }
        res.converted_msg = res.original_msg.replace("on line " + res.src_line, new_msg);
        if (view.fileName) {
          res.converted_msg = "" + view.fileName + ": " + res.converted_msg;
        }
      }
      return res;
    },
    prettyPrintError: function(view) {
      var i, line, lineno, padding, padding_len, res, txt_lines, _i, _ref, _ref1;
      if (!view.error) {
        return "";
      } else {
        res = "<div style=\"border:1px solid #999;margin:10px;padding:10px;background-color:#fff;position:fixed;top:0;left:0;width:960px;z-index:9999;\">";
        res += "<b>" + (eh._ppEscape(view.error.converted_msg)) + "</b>";
        res += "\n  <br />--------<br />";
        res += "\n<div style=\"font-family:courier new;font-size:10pt;color:#900;\">";
        txt_lines = view.txt.split('\n');
        for (i = _i = _ref = view.error.toffee_line_range[0] - 3, _ref1 = view.error.toffee_line_range[1] + 1; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
          if ((i < 0) || i > txt_lines.length - 1) {
            continue;
          }
          line = eh._ppEscape(txt_lines[i]);
          lineno = i + 1;
          padding_len = 5 - ("" + lineno).length;
          padding = ((function() {
            var _j, _results;
            _results = [];
            for (i = _j = 0; 0 <= padding_len ? _j < padding_len : _j > padding_len; i = 0 <= padding_len ? ++_j : --_j) {
              _results.push("&nbsp;");
            }
            return _results;
          })()).join("");
          res += "\n" + lineno + ": " + padding + " " + line + " <br />";
        }
        res += "\n</div>";
        res += "\n</div>";
        return res;
      }
    }
  };

  _ppEscape = function(txt) {
    var i, m;
    txt = txt.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
    m = txt.match(/^[\t ]*/);
    txt = txt.replace(m[0], ((function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = m[0].length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push("&nbsp;");
      }
      return _results;
    })()).join(""));
    return txt;
  };

}).call(this);
